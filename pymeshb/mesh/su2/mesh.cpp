#include <algorithm>
#include <fstream>
#include <regex>
#include <sstream>

#include "../util.hpp"
#include "element.hpp"
#include "mesh.hpp"
#include "solution.hpp"

namespace pymeshb {
namespace su2 {

py::tuple read_mesh(const std::string& meshpath, const std::string& solpath,
                    bool read_sol) {
    // Check if file exists
    std::ifstream mesh_file(meshpath);
    if (!mesh_file.is_open()) {
        throw std::runtime_error("Failed to open mesh: " + meshpath);
    }

    // Parse dimension
    int dim = 2;
    std::string line;
    while (std::getline(mesh_file, line)) {
        if (line.empty() || line[0] == '%') {
            continue;
        }
        if (line.find("NDIME=") != std::string::npos) {
            std::istringstream iss(line.substr(line.find("=") + 1));
            iss >> dim;
            break;
        }
    }

    // Elements
    int elem_count = 0;
    while (std::getline(mesh_file, line)) {
        if (line.empty() || line[0] == '%') {
            continue;
        }
        if (line.find("NELEM=") != std::string::npos) {
            std::istringstream iss(line.substr(line.find("=") + 1));
            iss >> elem_count;
            break;
        }
    }

    if (elem_count == 0) {
        throw std::runtime_error("No elements found in the mesh");
    }

    // Read elements
    py::dict elements;
    if (!read_elements(mesh_file, elem_count, elements)) {
        throw std::runtime_error("Failed to read elements from the mesh");
    }

    // Vertices
    int num_ver = 0;
    while (std::getline(mesh_file, line)) {
        if (line.empty() || line[0] == '%') {
            continue;
        }
        if (line.find("NPOIN=") != std::string::npos) {
            std::istringstream iss(line.substr(line.find("=") + 1));
            iss >> num_ver;
            break;
        }
    }

    if (num_ver == 0) {
        throw std::runtime_error("No vertices found in the mesh");
    }

    // Vertex coordinates
    py::array_t<double> coords(std::vector<py::ssize_t>{num_ver, dim});
    auto coords_ptr = coords.mutable_data();

    for (int i = 0; i < num_ver && std::getline(mesh_file, line); i++) {
        if (line.empty() || line[0] == '%') {
            // Skip empty lines or comments
            i--;
            continue;
        }

        std::istringstream iss(line);
        for (int j = 0; j < dim; j++) {
            iss >> coords_ptr[i * dim + j];
        }
        // Skip node index
        int node_idx;
        iss >> node_idx;
    }

    // Parse boundary conditions
    int boundary_count = 0;
    while (std::getline(mesh_file, line)) {
        if (line.empty() || line[0] == '%') {
            continue;
        }
        if (line.find("NMARK=") != std::string::npos) {
            std::istringstream iss(line.substr(line.find("=") + 1));
            iss >> boundary_count;
            break;
        }
    }

    // Read boundary elements
    py::dict boundaries;
    if (boundary_count > 0) {
        if (!read_boundary_elements(mesh_file, boundary_count, boundaries)) {
            throw std::runtime_error("Failed to read boundary elements from the mesh");
        }
    }

    // Read solution if requested
    py::dict sol;
    if (read_sol && !solpath.empty()) {
        sol = read_solution(solpath, num_ver, dim);
    }

    // Return coords, elements and solution if available
    if (read_sol && sol.size() > 0) {
        return py::make_tuple(coords, elements, boundaries, sol);
    } else {
        return py::make_tuple(coords, elements, boundaries);
    }
}

bool write_mesh(const std::string& meshpath, py::array_t<double> coords,
                const py::dict& elements, const py::dict& boundaries,
                const std::string& solpath, py::dict sol) {
    // Get dimensions
    int dim = coords.shape(1);
    int num_ver = coords.shape(0);

    // Create output directory if needed
    if (!pymeshb::createDirectory(meshpath)) {
        throw std::runtime_error("Failed to create directory for mesh file");
    }

    // Process elements and boundaries
    std::map<std::string, std::vector<std::vector<unsigned int>>> interior_elements;
    std::map<int, std::vector<std::vector<unsigned int>>> boundary_elements;

    int total_elements = process_elements_for_writing(
        elements, boundaries, dim, interior_elements, boundary_elements);

    // Write the mesh
    std::ofstream mesh_file;
    mesh_file.open(meshpath);
    mesh_file.precision(15);
    if (!mesh_file.is_open()) {
        throw std::runtime_error("Failed to open mesh file for writing: " + meshpath);
    }

    // Write dimension
    mesh_file << "% SU2 mesh file generated by pymeshb" << std::endl;
    mesh_file << "%" << std::endl;
    mesh_file << "% Problem dimension" << std::endl;
    mesh_file << "%" << std::endl;
    mesh_file << "NDIME= " << dim << std::endl;

    // Write elements
    mesh_file << "%" << std::endl;
    mesh_file << "% Inner element connectivity" << std::endl;
    mesh_file << "%" << std::endl;
    mesh_file << "NELEM= " << total_elements << std::endl;

    write_elements(mesh_file, interior_elements, get_reverse_element_type_map());

    // Write vertices
    auto coords_ptr = coords.data();
    mesh_file << "%" << std::endl;
    mesh_file << "% Node coordinates" << std::endl;
    mesh_file << "%" << std::endl;
    mesh_file << "NPOIN= " << num_ver << std::endl;

    for (int i = 0; i < num_ver; i++) {
        for (int j = 0; j < dim; j++) {
            mesh_file << std::fixed << coords_ptr[i * dim + j] << "\t";
        }
        mesh_file << i << std::endl;
    }

    // Write boundary markers
    mesh_file << "%" << std::endl;
    mesh_file << "% Boundary elements" << std::endl;
    mesh_file << "%" << std::endl;
    mesh_file << "NMARK= " << boundary_elements.size() << std::endl;

    write_boundary_elements(mesh_file, boundary_elements);

    mesh_file.close();

    // Write solution if provided
    if (!sol.empty() && !solpath.empty()) {
        return write_solution(solpath, sol, num_ver, dim);
    }

    return true;
}

}  // namespace su2
}  // namespace pymeshb