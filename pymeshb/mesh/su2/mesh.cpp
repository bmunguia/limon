#include <algorithm>
#include <fstream>
#include <regex>
#include <sstream>

#include "../util.hpp"
#include "element.hpp"
#include "mesh.hpp"
#include "solution.hpp"

namespace pymeshb {
namespace su2 {

py::tuple read_mesh(const std::string& meshpath, const std::string& markerpath,
                    const std::string& solpath, bool read_sol) {
    // Check if file exists
    std::ifstream mesh_file(meshpath);
    if (!mesh_file.is_open()) {
        throw std::runtime_error("Failed to open mesh: " + meshpath);
    }

    // Parse dimension
    int dim = 2;
    std::string line;
    while (std::getline(mesh_file, line)) {
        if (line.empty() || line[0] == '%') {
            continue;
        }
        if (line.find("NDIME=") != std::string::npos) {
            std::istringstream iss(line.substr(line.find("=") + 1));
            iss >> dim;
            break;
        }
    }

    // Elements
    int elem_count = 0;
    while (std::getline(mesh_file, line)) {
        if (line.empty() || line[0] == '%') {
            continue;
        }

        if (line.find("NELEM=") != std::string::npos) {
            std::istringstream iss(line.substr(line.find("=") + 1));
            iss >> elem_count;
            break;
        }
    }

    py::dict elements;
    if (dim == 2) {
        read_elements_2D(mesh_file, elem_count, elements);
    } else {
        read_elements_3D(mesh_file, elem_count, elements);
    }

    // Vertices
    int num_ver = 0;
    while (std::getline(mesh_file, line)) {
        if (line.empty() || line[0] == '%') {
            continue;
        }
        if (line.find("NPOIN=") != std::string::npos) {
            std::istringstream iss(line.substr(line.find("=") + 1));
            iss >> num_ver;
            break;
        }
    }

    if (num_ver == 0) {
        throw std::runtime_error("No vertices found in the mesh");
    }

    // Vertex coordinates
    py::array_t<double> coords(std::vector<py::ssize_t>{num_ver, dim});
    auto coords_ptr = coords.mutable_data();

    for (int i = 0; i < num_ver && std::getline(mesh_file, line); i++) {
        if (line.empty() || line[0] == '%') {
            // Skip empty lines or comments
            i--;
            continue;
        }

        std::istringstream iss(line);
        for (int j = 0; j < dim; j++) {
            iss >> coords_ptr[i * dim + j];
        }
        // Skip node index
        int node_idx;
        iss >> node_idx;
    }

    // Boundary elements
    int boundary_count = 0;
    while (std::getline(mesh_file, line)) {
        if (line.empty() || line[0] == '%') {
            continue;
        }

        if (line.find("NMARK=") != std::string::npos) {
            std::istringstream iss(line.substr(line.find("=") + 1));
            iss >> boundary_count;
            break;
        }
    }

    py::dict boundaries;
    read_boundary_elements(mesh_file, boundary_count, boundaries, markerpath);

    // Read solution if requested
    py::dict sol;
    if (read_sol && !solpath.empty()) {
        sol = read_solution(solpath, num_ver, dim);
    }

    // Return coords, elements and solution if available
    return py::make_tuple(coords, elements, boundaries, sol);
}

bool write_mesh(const std::string& meshpath, py::array_t<double> coords,
                const py::dict& elements, const py::dict& boundaries,
                const std::string& markerpath, const std::string& solpath,
                py::dict sol) {
    // Get dimensions
    int dim = coords.shape(1);
    int num_ver = coords.shape(0);

    // Create output directory if needed
    if (!pymeshb::createDirectory(meshpath)) {
        throw std::runtime_error("Failed to create directory for mesh file");
    }

    // Write the mesh
    std::ofstream mesh_file;
    mesh_file.open(meshpath);
    mesh_file.precision(15);
    if (!mesh_file.is_open()) {
        throw std::runtime_error("Failed to open mesh file for writing: " + meshpath);
    }

    // Write dimension
    mesh_file << "% SU2 mesh file generated by pymeshb" << std::endl;
    mesh_file << "%" << std::endl;
    mesh_file << "% Problem dimension" << std::endl;
    mesh_file << "%" << std::endl;
    mesh_file << "NDIME= " << dim << std::endl;

    // Write elements
    int elem_count = 0;
    for (auto item : elements) {
        auto element_array = item.second.cast<py::array_t<unsigned int>>();
        elem_count += element_array.shape(0);
    }
    mesh_file << "%" << std::endl;
    mesh_file << "% Inner element connectivity" << std::endl;
    mesh_file << "%" << std::endl;
    mesh_file << "NELEM= " << elem_count << std::endl;

    write_elements(mesh_file, elements);

    // Write vertices
    auto coords_ptr = coords.data();
    mesh_file << "%" << std::endl;
    mesh_file << "% Node coordinates" << std::endl;
    mesh_file << "%" << std::endl;
    mesh_file << "NPOIN= " << num_ver << std::endl;

    for (int i = 0; i < num_ver; i++) {
        for (int j = 0; j < dim; j++) {
            mesh_file << std::fixed << coords_ptr[i * dim + j] << "\t";
        }
        mesh_file << i << std::endl;
    }

    // Write boundary markers
    int marker_count = 0;
    if (!boundaries.empty()) {
        std::set<unsigned int> unique_markers;

        // Extract unique markers from boundaries
        auto process_boundary_type = [&unique_markers](const py::dict& boundaries, const std::string& key) {
            if (boundaries.contains(key)) {
                auto element_array = boundaries[key.c_str()].cast<py::array_t<unsigned int>>();
                auto elem_ptr = element_array.data();
                int num_elem = element_array.shape(0);
                int num_node = element_array.shape(1) - 1;

                for (int i = 0; i < num_elem; i++) {
                    unsigned int ref = elem_ptr[i * (num_node + 1) + num_node];
                    unique_markers.insert(ref);
                }
            }
        };
        // Process each boundary type
        process_boundary_type(boundaries, "Edges");
        process_boundary_type(boundaries, "Triangles");
        process_boundary_type(boundaries, "Quadrilaterals");

        marker_count = unique_markers.size();
    }
    mesh_file << "%" << std::endl;
    mesh_file << "% Boundary elements" << std::endl;
    mesh_file << "%" << std::endl;
    mesh_file << "NMARK= " << marker_count << std::endl;
    write_boundary_elements(mesh_file, boundaries, markerpath);

    mesh_file.close();

    // Write solution if provided
    if (!sol.empty() && !solpath.empty()) {
        return write_solution(solpath, sol, num_ver, dim);
    }

    return true;
}

}  // namespace su2
}  // namespace pymeshb