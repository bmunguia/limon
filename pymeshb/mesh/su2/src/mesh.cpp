#include <algorithm>
#include <fstream>
#include <regex>
#include <sstream>

#include "../../util.hpp"
#include "../include/element.hpp"
#include "../include/mesh.hpp"

namespace pymeshb {
namespace su2 {

py::tuple read_mesh(const std::string& meshpath, const std::string& markerpath) {
    // Check if file exists
    std::ifstream mesh_file(meshpath);
    if (!mesh_file.is_open()) {
        throw std::runtime_error("Failed to open mesh: " + meshpath);
    }

    // Parse dimension
    int dim = 2;
    std::string line;
    while (std::getline(mesh_file, line)) {
        if (line.empty() || line[0] == '%') {
            continue;
        }
        if (line.find("NDIME=") != std::string::npos) {
            std::istringstream iss(line.substr(line.find("=") + 1));
            iss >> dim;
            break;
        }
    }

    // Elements
    int elem_count = 0;
    while (std::getline(mesh_file, line)) {
        if (line.empty() || line[0] == '%') {
            continue;
        }

        if (line.find("NELEM=") != std::string::npos) {
            std::istringstream iss(line.substr(line.find("=") + 1));
            iss >> elem_count;
            break;
        }
    }

    py::dict elements;
    if (dim == 2) {
        read_elements_2D(mesh_file, elem_count, elements);
    } else {
        read_elements_3D(mesh_file, elem_count, elements);
    }

    // Points
    int num_point = 0;
    while (std::getline(mesh_file, line)) {
        if (line.empty() || line[0] == '%') {
            continue;
        }
        if (line.find("NPOIN=") != std::string::npos) {
            std::istringstream iss(line.substr(line.find("=") + 1));
            iss >> num_point;
            break;
        }
    }

    if (num_point == 0) {
        throw std::runtime_error("No points found in the mesh");
    }

    // Vertex coordinates
    py::array_t<double> coords(std::vector<py::ssize_t>{num_point, dim});
    auto coords_ptr = coords.mutable_data();

    for (int i = 0; i < num_point && std::getline(mesh_file, line); i++) {
        if (line.empty() || line[0] == '%') {
            // Skip empty lines or comments
            i--;
            continue;
        }

        std::istringstream iss(line);
        for (int j = 0; j < dim; j++) {
            iss >> coords_ptr[i * dim + j];
        }
        // Skip node index
        int node_idx;
        iss >> node_idx;
    }

    // Boundary elements
    int boundary_count = 0;
    while (std::getline(mesh_file, line)) {
        if (line.empty() || line[0] == '%') {
            continue;
        }

        if (line.find("NMARK=") != std::string::npos) {
            std::istringstream iss(line.substr(line.find("=") + 1));
            iss >> boundary_count;
            break;
        }
    }

    py::dict boundaries;
    read_boundary_elements(mesh_file, boundary_count, boundaries, markerpath);

    return py::make_tuple(coords, elements, boundaries);
}

bool write_mesh(const std::string& meshpath, py::array_t<double> coords,
                const py::dict& elements, const py::dict& boundaries,
                const std::string& markerpath) {
    // Get dimensions
    int dim = coords.shape(1);
    int num_point = coords.shape(0);

    // Create output directory if needed
    if (!pymeshb::createDirectory(meshpath)) {
        throw std::runtime_error("Failed to create directory for mesh file");
    }

    // Write the mesh
    std::ofstream mesh_file;
    mesh_file.open(meshpath);
    mesh_file.precision(15);
    if (!mesh_file.is_open()) {
        throw std::runtime_error("Failed to open mesh file for writing: " + meshpath);
    }

    // Write dimension
    mesh_file << "% SU2 mesh file generated by pymeshb" << std::endl;
    mesh_file << "%" << std::endl;
    mesh_file << "% Problem dimension" << std::endl;
    mesh_file << "%" << std::endl;
    mesh_file << "NDIME= " << dim << std::endl;

    // Write elements
    int elem_count = 0;
    for (auto item : elements) {
        auto element_array = item.second.cast<py::array_t<unsigned int>>();
        elem_count += element_array.shape(0);
    }
    mesh_file << "%" << std::endl;
    mesh_file << "% Inner element connectivity" << std::endl;
    mesh_file << "%" << std::endl;
    mesh_file << "NELEM= " << elem_count << std::endl;

    write_elements(mesh_file, elements);

    // Write points
    auto coords_ptr = coords.data();
    mesh_file << "%" << std::endl;
    mesh_file << "% Node coordinates" << std::endl;
    mesh_file << "%" << std::endl;
    mesh_file << "NPOIN= " << num_point << std::endl;

    for (int i = 0; i < num_point; i++) {
        for (int j = 0; j < dim; j++) {
            mesh_file << std::fixed << coords_ptr[i * dim + j] << "\t";
        }
        mesh_file << i << std::endl;
    }

    // Write boundary markers
    int marker_count = 0;
    if (!boundaries.empty()) {
        std::set<unsigned int> unique_markers;

        // Extract unique markers from boundaries
        auto process_boundary_type = [&unique_markers](const py::dict& boundaries, const std::string& key) {
            if (boundaries.contains(key)) {
                auto element_array = boundaries[key.c_str()].cast<py::array_t<unsigned int>>();
                auto elem_ptr = element_array.data();
                int num_elem = element_array.shape(0);
                int num_node = element_array.shape(1) - 1;

                for (int i = 0; i < num_elem; i++) {
                    unsigned int ref = elem_ptr[i * (num_node + 1) + num_node];
                    unique_markers.insert(ref);
                }
            }
        };
        // Process each boundary type
        process_boundary_type(boundaries, "Edges");
        process_boundary_type(boundaries, "Triangles");
        process_boundary_type(boundaries, "Quadrilaterals");

        marker_count = unique_markers.size();
    }
    mesh_file << "%" << std::endl;
    mesh_file << "% Boundary elements" << std::endl;
    mesh_file << "%" << std::endl;
    mesh_file << "NMARK= " << marker_count << std::endl;
    write_boundary_elements(mesh_file, boundaries, markerpath);

    mesh_file.close();

    return true;
}

}  // namespace su2
}  // namespace pymeshb